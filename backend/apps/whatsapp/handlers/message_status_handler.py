"""
Handler para evento messages.update (atualiza√ß√£o de status de mensagem).
"""
import logging
from typing import Dict, Any
from django.utils import timezone
from django.http import HttpResponse
from apps.messaging.models import Message
from apps.whatsapp.handlers.base_handler import BaseWebhookHandler
from apps.whatsapp.controllers.webhook_controller import (
    create_success_response,
    create_error_response
)
from apps.whatsapp.models import WhatsAppSession

logger = logging.getLogger(__name__)


class MessageStatusHandler(BaseWebhookHandler):
    """
    Handler para evento messages.update.
    Atualiza o status de mensagens existentes com base no recebido.

    AGORA TAMBEM ATUALIZA:
    - CampaignItem.status baseado no status da mensagem
    - Contadores da campanha (messages_delivered, messages_read, messages_failed)
    - Timestamps (delivered_at, read_at)
    """

    def handle(self, request) -> HttpResponse:
        """
        Processa atualiza√ß√£o de status de mensagem.
        """
        self.event_data = self.get_event_data(request)
        if not self.event_data:
            return self.create_error_response(
                error_code='INVALID_EVENT',
                error_message='Dados do evento n√£o encontrados'
            )

        direction = self.event_data.get('data', {}).get('direction', '')
        if direction != 'out':
            logger.error(f"Direction inv√°lida: {direction}")
            return self.create_error_response(
                error_code='INVALID_DIRECTION',
                error_message=f"Direction deve ser 'out', recebido: {direction}"
            )

        # Extrai dados
        message_id = self.event_data.get('data', {}).get('messageId')
        message_status = self.event_data.get('data', {}).get('status')

        if not message_id or not message_status:
            logger.error(f"messageId ou status n√£o encontrados")
            return self.create_error_response(
                error_code='MISSING_FIELDS',
                error_message='IDs da mensagem ou status n√£o fornecidos'
            )

        # Busca mensagens por message_id
        # Pode haver m√∫ltiplas mensagens com mesmo ID (para diferentes destinat√°rios)
        messages = Message.objects.filter(whatsapp_message_id=message_id)

        if not messages.exists():
            logger.warning(f"Nenhuma mensagem encontrada com message_id: {message_id}")
            # Cria nova mensagem com status recebido
            Message.objects.create(
                direction='in',
                status=message_status,
                message_type='text',
                content=message_status,  # O status vem como texto no messages.update
                whatsapp_message_id=message_id,
                external_id=message_id,
            )
            logger.info(f"Status atualizado para nova mensagem (criada): {message_id} -> {message_status}")
            count = 1
        else:
            # Atualiza mensagens existentes
            count = messages.update(
                status=message_status.lower()
            )

            logger.info(f"Status atualizado para {count} mensagens existentes: {message_id} -> {message_status}")

        return create_success_response(
            data={
                'direction': direction,
                'messageId': message_id,
                'updatedCount': count
            },
            message=f"Status de {count} mensagens atualizado para '{message_status}'"
        )

    def _process_message_update(
        self,
        session: WhatsAppSession,
        payload: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        Processa evento messages.update (chamado pela task).

        Atualiza CampaignItem e contadores da campanha com base no status recebido.

        Args:
            session: Sess√£o WhatsApp que recebeu o evento
            payload: Payload completo do webhook

        Returns:
            Dict com resultado do processamento
        """
        from apps.campaigns.models import Campaign, CampaignItem

        try:
            # Extrai dados do payload
            data = payload.get('data', {})
            message_id = data.get('messageId')
            message_status = data.get('status', '').upper()
            key_id = data.get('keyId', '')

            logger.info("="*80)
            logger.info(f"üìä MESSAGES.UPDATE - Status: {message_status}")
            logger.info(f"   Message ID: {message_id}")
            logger.info(f"   Key ID: {key_id}")
            logger.info("="*80)

            # Valida dados
            if not message_id:
                return {'error': 'messageId n√£o fornecido'}

            if not message_status:
                return {'error': 'status n√£o fornecido'}

            # Busca CampaignItem correspondente
            campaign_item = CampaignItem.objects.filter(
                message_id=message_id
            ).first()

            if not campaign_item:
                logger.warning(f"CampaignItem n√£o encontrada para message_id: {message_id}")
                logger.info(f"   ‚ö†Ô∏è  CampaignItem n√£o encontrada")
                return {
                    'success': True,
                    'message': 'CampaignItem n√£o encontrado (n√£o √© mensagem de campanha)',
                    'message_id': message_id
                }

            campaign = campaign_item.campaign
            logger.info(f"   üì¢ Campanha: {campaign.name}")
            logger.info(f"   Destinat√°rio: {campaign_item.recipient_name}")
            logger.info(f"   Status anterior: {campaign_item.status}")

            # Mapeia status da Evolution API para CampaignItem
            status_mapping = {
                'PENDING': CampaignItem.Status.PENDING,
                'SERVER_ACK': CampaignItem.Status.QUEUED,
                'DELIVERY_ACK': CampaignItem.Status.DELIVERED,
                'READ': CampaignItem.Status.READ,
                'FAILED': CampaignItem.Status.FAILED,
            }

            new_status = status_mapping.get(message_status)

            # Atualiza CampaignItem baseado no status
            update_fields = ['status', 'updated_at']
            update_message = ''

            if message_status == 'DELIVERY_ACK':
                # Mensagem entregue ao destinat√°rio
                campaign_item.delivered_at = timezone.now()
                campaign_item.status = CampaignItem.Status.DELIVERED
                update_fields.extend(['delivered_at'])

                # Atualiza contador da campanha
                campaign.messages_delivered += 1
                campaign.save(update_fields=['messages_delivered'])

                update_message = f"‚úÖ MENSAGEM ENTREGUE para {campaign_item.recipient_name}"

            elif message_status == 'READ':
                # Mensagem lida pelo destinat√°rio
                campaign_item.read_at = timezone.now()
                campaign_item.status = CampaignItem.Status.READ
                update_fields.extend(['read_at'])

                # Atualiza contador da campanha
                campaign.messages_read += 1
                campaign.save(update_fields=['messages_read'])

                update_message = f"üìñ MENSAGEM LIDA por {campaign_item.recipient_name}"

            elif message_status == 'FAILED':
                # Mensagem falhou
                campaign_item.status = CampaignItem.Status.FAILED
                campaign_item.error_message = f"Falha no envio: {message_status}"

                # Atualiza contador da campanha
                campaign.messages_failed += 1
                campaign.save(update_fields=['messages_failed'])

                update_message = f"‚ùå MENSAGEM FALHOU para {campaign_item.recipient_name}"

            elif message_status == 'SERVER_ACK':
                # Mensagem enviada para o servidor do WhatsApp
                if campaign_item.status == CampaignItem.Status.PENDING:
                    campaign_item.status = CampaignItem.Status.QUEUED
                    campaign_item.sent_at = timezone.now()
                    update_fields.extend(['sent_at'])

                    update_message = f"üì§ MENSAGEM ENVIADA para {campaign_item.recipient_name}"

            # Salva CampaignItem
            campaign_item.save(update_fields=update_fields)

            logger.info(
                f"CampaignItem {campaign_item.id} atualizado: "
                f"{campaign_item.status} (msg: {message_status})"
            )

            logger.info(f"   Status atualizado: {campaign_item.status}")
            logger.info(f"   üìä Estat√≠sticas da Campanha:")
            logger.info(f"      ‚úâÔ∏è  Enviadas: {campaign.messages_sent}")
            logger.info(f"      ‚úÖ Entregues: {campaign.messages_delivered}")
            logger.info(f"      üìñ Lidas: {campaign.messages_read}")
            logger.info(f"      ‚ùå Falhas: {campaign.messages_failed}")

            return {
                'success': True,
                'campaign_id': campaign.id,
                'campaign_item_id': campaign_item.id,
                'status': campaign_item.status,
                'message_status': message_status
            }

        except CampaignItem.DoesNotExist:
            logger.warning(f"CampaignItem n√£o encontrada para message_id: {message_id}")
            return {
                'success': True,
                'message': 'CampaignItem n√£o encontrado',
                'message_id': message_id
            }
        except Exception as e:
            logger.exception(f"Erro ao processar message update: {e}")
            return {'error': str(e)}
